
## 更新日志

## 已发现明显缺陷

1. 反陀螺的跟随部分和非反陀螺的信号发送逻辑一致，这可能会导致等待到跟随直接目标之初跟不上。
2. 装甲板朝向角算法存在误差，且误差不是正态的。
3. 由于 pnp 测距的巨大方差，以及因光线等问题对侧向装甲板测距存在稳态误差，top4::TopModel 难以准确测量 3m 外的车辆半径，导致打击 3m 外的陀螺命中率严重下滑。
4. pnp 的稳态误差还导致大多数车打 6m 外静止装甲板落点有问题，通常是距离偏近，落点偏低。猜测原因是远处灯条光晕更大，或焦距失效，或者关于固定灯条尺寸表 constants.hpp 中的 PW_SMALL。
5. 存在陀螺仪在不同朝向给出的 pitch 存在变化或其他问题，导致落点在一个朝向调准后，另一个方向无法调准，或者打低处调准后，打高处不准。很多步兵在打坡上的英雄落点偏高，原因尚不知。
6. ekf 结合 pid 无法良好跟随频繁弹射的哨兵（急眼模式）。

## 23-01-31 13:08

1. 由于自瞄实际使用的坐标系为陀螺仪坐标系，而原先名称为世界坐标系，如 `pw`，现在已经改为 `pi`，其中 `i` 表示 `imu`（惯性测量单元）。

## 23-01-28 12:11

1. 按照 Chromium 规则优化了防止重复包含的宏。

## 22-12-13 18:15

1. 自瞄 EnemyPredictor 的 predict 函数拆分了。

## 22-12-12 02:20

1. 自瞄修改部分函数名称。
2. ignore 文件的替代文件的名称调整。

## 22-12-9 22:05

1. CoordConverter 新增 一次畸变点 转 相机球面坐标 yaw pitch 的函数 pd_to_yp_c()。

## 12月9日 21:42

1. 为了迎接英雄吊射，自瞄架构调整。而且文件夹 armor 变成了 aimer。任何瞄准功能的通用组件在 aimer/base 中。

> 参数表 assets/aimer_param.yml 变动，旧表无法使用。

## 11月30日 01:08

1. 初步完成瞄准校正器逻辑。目前问题：识别子弹速度慢至几十毫秒；识别召回率和精准率较低；通过卡尔曼滤波校正可能存在问题。

> 参数表 assets/aimer_param.yml 变动，旧表无法使用。

## 11月21日 19:02

1. 风格按照之前的建议优化，纠正若干英文错词。

> 参数表 assets/aimer_param.yml 变动，旧表无法使用。

## 11月16日 21:04

1. 弹道预估添加序号和其他小修改。

> 参数表 assets/aimer_param.yml 变动，旧表无法使用。

## 11月15日 22:14

1. 弹道检测加入和电控配合的部分。

> robot.hpp 协议需更新。

## 11月10日 01:55

1. 命名空间变短了。

> 以后要思考码风只追求高可读性和维护性，方便未来的自己和其他读者理解。不能追求贴合 C++ 语法设计。

## 11月8日 12:53 逻辑修正，flask bug 修复

1. 弹道预估之前发射时机参数错了，现在修复了这个错误，使得无论怎么调整延迟参数，模拟时子弹一定能击中匀速目标。
2. 精简了若干函数。我们希望一个类的成员函数只需要管理这个类的成员的交互逻辑，交互内容应该交给成员去做。也许这样是理想的：

```cpp
auto ClassType::instance_method1() -> Type {
  const auto res1 = this->member1.do();
  res1.check();
  const auto res2 = this->member2.do(res1);
  res2.check();
}
```

3. 修复了 flask 一直以来的 bug：如果发布器是空的，程序就会无法 Ctrl + C 终止。在 scripts/bridge.py 中修改一个 pop() 函数为 pop_for(2000) 即可。
4. 电控模拟类更新，现在可用参数调整发射冷却。

> 参数表调整，旧表不可用。

## 11月6日 08:37 弹道预估和大量逻辑调整

1. 添加了弹道预估功能。
2. 调整了一些运算逻辑。

> 参数表 assets/aimer_param.yml 变动，旧表无法使用。

## 8月28日 14:10

1. 装甲板模型（aimer::MotionModel）在新建滤波器线程时不再 update，且构造函数内会进行信任计时器的更新。
2. 原先的 PtsProjector 类只是集成了 3 个投影函数，现在拆出了这三个函数到 top 命名空间里。
3. 略微简化了反陀螺获取目标函数。
4. 制作了两种周期数据监视器，记录最近一个周期（该值添加至 **参数表内参数**）内最大单次预测时间用以监视算法效率，以及平均 desired_yaw 用以辅助调节 ADDITIONAL_PREDICTION_TIME。
5. 查到“平衡车”英文是 balance-robot，所以原先 balanced 字串都换成了 balance，平衡步兵为 balance-infantry。
> （已经废弃）6. 变量初始化方式逐渐改为统一初始化方法，例如 `int i{5};`。因为 C++11 标准推荐使用，且这种写法容易与 **赋值** 和 **函数声明** 进行区分。

> 参数表 assets/aimer_param.yml 变动，旧表无法使用。

## 8月10日 08:08

1. 考虑到守株待兔模式跟随区间等于发射区间这一逻辑会错失有效发射，尤其是手动调整角度后的第一发，现在分离了跟随区间和发射区间参数。
2. 高建筑兵种感兴趣区域起始 y 添加为可修改的参数。
3. Ekf 结构和语法更规范，主要是重新分离了预测和观测过程。上赛季两过程分离，本赛季原先合并，但这破坏了系统，且在角度突越点数据处理遭遇困难，故重新分离。但是 kalman 仍然保留了 predict_order，这并不规范。部分 kf 滤波器改用 ekf，只需写好伪函数即可。注意，全车模型半径和高度滤波器已经改用新增的 SingleFilter<1>，对于 1 维数据本意是测量常量，不存在预测过程误差，但目前该滤波器仍然保留预测过程，方差为 1，观测方差为 **参数** 置于参数表中，以防远处光线等原因造成的系统误差永久存在。
4. 全车模型采样的半径采纳的先验方差与采样中心距离成平方比。
5. 代码消除了一些 -Wall 下的警告。
6. aimer::ArmorData 数据类优化，用 aimer::ArmorInfo 类分离了填入 id 步，area 和 center 等数据函数化，并分离出 aimer::SampleArmor 类，使这类数据不存在空置数据或冗余数据。

> 参数表 assets/aimer_param.yml 已变动，**旧版无法使用**。

> 单执行语句的 for 循环可以不用大括号是为了使代码更紧凑，也就是让流程更易读。
> 最好不要以 **效果** 为驱动力，应该以 **逻辑** 为驱动力。当发现 **效果** 存在问题时，应该溯源找到系统的哪个部分出了问题。效果是这样来的：原因 -> 逻辑 -> 代码 -> 效果。当不能定位系统的哪个部分出问题时，不要通过修改别的部分来达到效果，例如，不要把 距离 - 抬头补偿表格 写入代码的主分支，那最多作为一个放弃更新的实用分支。但也可以通过摧毁系统的若干个不合理部分来达到效果，有时也需要 **基于** 某个原因引入新的部分。当然不得不说有的时候硬补偿真香。

## 8月4日 19:57

1. 守株待兔模式（passive mode）预测和跟随逻辑调整。
2. 为不同兵种提供不同的感兴趣区域。目前，前哨站和哨兵必须在视觉视野的下半屏才会被选择为新目标。该功能可在参数表内开启或关闭。

## 8月1日 19:41

1. 参数表提供关闭电控补偿角的选项，这是因为部分机器人的电控代码不使用补偿角。
2. 参数表提供 2021 版计算落点抬头补偿的选项。

> 参数表 aimer_param.yml 更新，旧版无法使用。

## 7月31日 19:51

1. 变量名称修改。这是为了易读性。

## 7月31日 17:30

1. 为测试守株待兔模式，添加强制修改 RobotCmd 量的参数表接口。
2. 抛物线补偿修正。之前用的坐标系有点问题。
3. 添加调节预测回归次数的参数表接口。
4. 修复反陀螺内部 "emerging" 时间点计算的问题。

> 参数表 aimer_param.yml 有列表改动（旧表无法使用），同时有一些旧参数更新。

## 7月29日 18:25

1. 对于非单参数构造函数，取消 explicit 限定。同时在 aimer::math::YpdCoord 和 Eigen::VectorXd 构造时更多使用列表初始化，以期可读性的提升。
  
> explicit 限定应只限制 `UpdateOption option = true` 这种情形。而 `Eigen::Vector3d pos(1, 0)` 使人难以分清这是调用 **构造函数** 还是调用 **重载运算符()**。

## 7月29日 18:04

1. 参数表调整，不再按参数类型排序，按照算法结构逻辑排序。
2. 平衡步兵识别机的时间参数提出到参数表。
3. 改写 EnemyModel 工厂生成和 aimer::EnemyModelInterface 销毁子类实例的方式，不再依赖运行时类型识别模式。aimer::EnemyModelInterface::alive() -> bool 将自动判断当前模型类型是否正确。

## 7月28日 19:55

1. 修复参数表 AIM_YAW_OFFSET 角度制未转弧度制的问题。
2. 参数表的参数顺序调整。

> 参数表 aimer_param.yml 修改。

## 7月28日 19:24

1. 之前相机 - 枪口补偿方法存在问题：在初计算坐标时就根据参数表补偿角度。事实上，本补偿设置的初衷是相机和枪口存在角度偏差，该补偿仅能把相机坐标修正到枪口坐标。而我们总是通过落点的偏差去调节该补偿，导致系统重力方向偏转，无法正确解算抛物线。重新梳理了坐标转换的过程以后，发现子弹抛物线抬头补偿并不需要 yaw pitch，只需要枪口坐标系下正确的 xyz 即可，因此简化了坐标转换过程，以期命中范围比之前更广。
2. aimer::MotionModel 提供打击哨兵时“等待打击”模式的开关，开关在参数表中。

> 参数表 aimer_param.yml 修改。

## 7月27日 20:33

1. PnpDistanceFixer 采用的参数之前不是实时更新的。现在改成实时更新了。

## 7月27日 15:46

1. flask 分离俯视图到另一个 checkbox。
2. 子弹空气阻力系数提出至参数表。
3. 发现打远处目标的枪口抖动仍然很大。ekf 所用的先验 **观测距离方差** 改用 MOTION_EKF_R_DISTANCE_AT_1M * dis * dis，与距离的平方成正比。

> 参数表 aimer_param.yml 修改。

## 7月26日 10:42

1. armor aim 视频增加俯视图，能显示视野范围、敌人装甲板运动和全车运动；此外添加了四向平面和立方体输出选项，帮助检查陀螺仪。

## 7月26日 03:38

1. ekf 处理了观测值 yaw pitch 在正负 180 度时的突变。未处理将导致 ekf 内部作差的部分在特殊角度出现跃差，乘以 ceres 一阶展开的系数后 xyz 大幅偏离，滤波器发散。同时修改了原来反陀螺使用的 AngleFilter 极小可能出现突变问题的部分。
2. aimer::ArmorData 结构体中的 area 从去畸变的 area 改为原始 area。目的是简化变量的定义。
3. armor aim 视频左上角增加 send.shoot 等显示信息。

## 7月25日 20:02

1. 修正参数表 typo。

## 7月22日 01:44

1. wtm 调英雄自瞄时反馈说打远处前哨站识别到但不打。估计是 aimer::EnemyState 类将一定距离外的目标删除的缘故，**现在该限制距离加入 yml 参数表**。

> 为什么保留限制距离？一是对方补给站有几个灯条容易被识别成装甲板，而距离限制应该可以筛除它们。二是担心有些小光条被识别成矩形的装甲板，也许可以用距离限制排出之。三是远处的目标几乎打不中，它们可能会成为自瞄应用时的干扰。

2. 参数表一些参数名称修改。

## 7月18日 10:18

1. 由于担心 EKF 内部协方差矩阵发散，修改了 EKF 之 P 矩阵的初值为单位矩阵 I，先前为 998244353. * I。因为听说单位矩阵是一个 convention。
2. 打前哨站时瞄中心浮动仍然较大。因此反陀螺中心放弃匀加速状态，改用匀速状态。但保留 predict_orders，这样前哨站的预测不给出速度，比较好。

## 7月17日 20:31

1. 调节 aimer::MotionModel 的创建逻辑，使之在创建时进行一次 update。
2. 修复反陀螺等待时选择间接目标逻辑的 bug。之前在 leaving_angle 处采用了 auto-aim.top-model.aim.max-swing-error，应该用 auto-aim.top-model.aim.max-out-error。

## 7月16日 15:02

1. aimer::MotionModel 装甲板运动模型内部滤波器换为 EKF，缓解远距离枪口稳定和跟踪速度的冲突并期望能打哨兵。
2. 添加 debug 源文件，其中包含输出 log 到 flask 的全局对象 flask_stream。
3. 放弃信任电控当前测量的 cmd_to_fire_latency，改为手动调参。

注意有参数表和其他常数修改。

## 7月11日 20:49

1. 重新思考了电控追踪控制和发射控制的逻辑，因此重构了视觉的命令逻辑。
2. 网页调参 UI 左侧添加了字符串 log。

## 7月4日 23:50

1. 所有参数均可在运行时作用（之前有的参数只能在初始化时作用），包括前哨站装甲板朝向角符号修正机可在运行时决定是否调用，以及 3、4、5 步兵是否为平衡步兵。另外，现保证创建参数对象后才会开始创建和运行预测器对象，这是通过在所有参数对象创建完成后额外创建一个信号对象实现的。

## 7月3日 15:48

> (弃用) 1. 发现最近分离参数初始化线程后，容易出现参数未读入就加载模型的问题。对于模型内部的处理方式，比如前哨站是否采用方向修正机，本质上确实应该在加载模型时决定。目前只能在主线程添加一个 0.5s 的休眠以等待参数读入。

## 7月1日 17:01

1. 修改文件布局，试图规范源文件和头文件管理。
2. 一阶预测优化，现在不再会给出速度。同时降低部分敌人模型对高度的预测的阶数，尤其是哨兵已经改成了无速度预测（一阶）。
3. 简化信任计时器。

## 6月25日 23:48

> （06-29抛弃）yml 参数表添加固定物理量“子弹出枪速度”选项。这是因为电控发来的子弹速度浮动较大。

## 6月25日 22:11

1. （实验功能）平移卡尔曼滤波的方差与距离的平方成正比，以期打击远距离静止目标减小抖动。
2. 添加物理量“相机到枪口的 yaw”接口（测量时向右为正），视觉将试图纠正这一物理量带来的弹道误差，且在纠正时，所有变量均有其直接物理意义。
3. 瞄准工程并自瞄时不再会主动切换到工程外的目标。

## 6月24日 23:21

分离 SingleArmor 模型为 Sentry 和 Statue，后者采用 3 阶转移和 1 阶预测，以期远距离打击水晶减少抖动。另外，非陀螺的前哨站也改用 1 阶预测。

## 6月24日 06:31

（实验功能）试图用二次函数简单修复 pnp 距离误差。

## 6月24日 04:09

之前 “定中心简单陀螺装甲板朝向角符号修正机 OrientationSignFixer” 采用 std::max 来取周期内较大的角，但实际上应该认为 -179 度（即 181 度）比 179 度大。现在 aimer::math::max_angle 修复了这一问题。另外，该机之前判断过长时间未更新（需重置）的鲁棒方式在极端情况下将会长时间无法重置，现修改为过长时间未重置则重置。

## 6月23日 17:10

常数修改。

## 6月22日 15:48

针对前哨站设计装甲板估计方向修复器 OrientationSignFixer。该修复器仅在对方中心在陀螺仪坐标下 yaw 无运动时（即对方中心相对我中心无平移运动）才可使用。

## 6月22日 09:10

添加线程可信倒计时器。

## 6月21日 18:47

1. 添加相机-枪口 pitch 角视觉补偿。
2. 为不同模型均添加漏帧保护。

## 6月20日 18:50

修复目标抓取保留的 bug。

## 6月15日 morning

1. 提升装甲板 id 赋值、平移模型和陀螺模型抗丢帧能力。之前陀螺模型设计并未考虑丢帧（尤其是两个可见板的情况下突然丢一个板）的情况。其中 id 赋值思路为：数据消失后保留线程，直到 0.1s 后，或该数字的装甲板线程过多，或与其他同数字板收纳范围相撞后删除。保留期间，任何收纳的装甲板将会进入该线程，而不是新增线程。
2. 选择打击目标机制优化。用 AimCatcher 类维护一定时间内的目标。当视野中一定时间无数据时，无论什么模式都会立即抛弃目标，防止调用 get_aim 去打早就飞走的滤波器（三板陀螺更新后，无数据也可能调用 get_aim)。

> 修复了下标越界致命错误。

## 6月13日 01:17

1. 拓展三板反陀螺模型，适用于平衡步兵（二板）反陀螺模型。并提升了其精度。
2. 添加了手动设置敌人运动模型的方案，需在程序运行前设置 predictor_param.yml。若 agx 有自启动，可以开机，设置 yml，重启 agx。

（提升了代码扩展性）

## 6月5日 15:49

（调整数据存储逻辑，避免同一变量多个访问接口的问题，以提升未来拓展代码的可能性）

## 6月3日 23:55

1. 陀螺模型激活改用双阈值，预防在激活点附近反复横跳的情况。
2. 可使用参数设置同一时间内追踪的敌人最大数目。
3. 增加针对新赛季前哨站的三板陀螺模型 top3::TopModel。目前尚在测试。主要不稳定因素在神经网络难以识别近处的前哨站，以及会把前哨站识别为水晶小装甲。另外，如果看到了前哨站头顶的装甲板，陀螺模型将失效（所以假设看不见头顶装甲板）。比赛时可能需要换回 SingleArmor 基本模型。

## 5月27日 morning

现在上车测试比较害怕的问题是相机线松了，光圈松了等。

1. 平衡步兵（没有两块板子）识别逻辑修改。之前识别效率与帧率有关。现在则设计为连续 0.1s 时间内每帧都有 >= 2 板，则会换为陀螺车运动模型。连续 15s 内每帧都仅有 1 板，则会换为平衡车。
2. 反陀螺等待射击的逻辑优化。之前容易在对方偏差过大时就开始打击。

> 由于实验中无法实时获得电控时间戳，且考虑到这个时间戳经过不稳定延迟的传输后不再可靠（拍照的时间戳要求精度很高，否则会严重影响自瞄算速度），放弃电控联合监听延迟。目前在尝试视觉和电控分别测延迟（视觉计算算法延迟，电控计算指令 - 开火延迟）。尽管上期测量时我不知道电控发 RobotStatus (电控结构体名称 MCUSendData_t) 数据包固定为 50ms 间隔发包，但测试得到的 82ms 平均值仍然可参考，因为间隔发包的大误差会平均分配到两边。

为什么尝试精准估计延迟？因为有的车转的太快了，反陀螺计算要打击的目标点时，所用的数据为相机图像，需要估计的是图像推算，到下令打击，到子弹飞出，到子弹击中敌人**这么长时间后**的目标装甲板位置。对于 120 转的舵轮，每 10ms 的误差就会导致目标装甲板已经转过去 7 度。反陀螺坐标坐标推算本身的误差尚可接受，但加上这样的 7 度就很可能打不中了。更糟糕的情况是，如果误差达到 30 度以上，反陀螺的命中率会是 0，刚好每发都打在两装甲板之间。

## 5月18日 02:22

昨日上车测试。

1. 反陀螺追踪也将发送 yaw_v，但该数值极大，对于 2m 处舵轮可达 150+ degree。
> （已放弃）2. 电控联合监听从计算打击点前一刻到对应子弹出射（利用裁判系统监听）的总延迟并投入滤波器，加上本帧测量的图像捕获时间到计算打击点前一刻的时间替代原先 PROCESS_LATENCY。但 PROCESS_LATENCY 参数仍然保留，以微调裁判系统信号传输、相机曝光等微小延迟。
    - 下午原理：电控 usb 高频率传给视觉 stm32 的时间戳，在 sensors.cpp > camera.read 捕获图像之前，记录 stm32 的时间戳并与图像绑定传给 detector，然后给 predictor。predictor 给电控 usb 发送 send 信号（其中包含相机图像对应的 stm32 时间戳），并由电控代码中 recvData 变量接收，recvData 将更新 AutoAim::autoAim 实例中记录本帧图像时间戳的成员变量，若 recvData 中包含 shoot 指令，电控的 Shoot::shoot 实例会根据热量和冷却等决定这个 shoot 指令是否真的发弹，并将 bool 返回 AutoAim::autoAim 实例；如果 shoot 决定发弹，此时 autoAim 实例将记录该指令对应的相机图像的 stm32 时间戳，电控发送电流并进入发弹冷却；随后裁判系统大概率在发弹冷却结束之前侦测到一次子弹飞出（如果实际无子弹飞出，也不会计算错误数据），若侦测到，则 JudgeTask.cpp 中的 Referee_Update_ShootData() 函数将调用 autoAim 实例计算视觉发弹指令到出射总延迟的函数，计算方法为此时 stm32 时间戳减去最近一次记录的图像时间戳。上机测试显示总延迟在 35 ～ 110ms 之间，平均约 82ms，与去年手工数据非常接近。
    - 在随后的改进中，相机捕获图像到预测器计算打击点的延迟被分离出来（因为它对本帧而言是可以计算以消除其影响的），发送给电控的指令时间戳为预测器计算打击点之前的时间戳。

> 修复上次代码里的低级 bug。

> 取消 typeid 的使用，以免依赖 RTTI。

## 5月13日 21:38

> （已抛弃）1. 接收电控的 shoot_latency 代替常数 PROCESS_LATENCY，需要联合修改 RobotStatus。
2. 添加计算 yaw_v 的传给电控，以提高对平移的追踪速度。
3. 角度采样仅用单板拟合，并以面积为系数，以期角速度样本的平滑，这样已经可以应对非匀速陀螺。半径采样用双板拟合。但是超过 2m 后拟合不准，因为距离测不准，会有左板 2.2m 右板 2.5m 的情况，视频中实际上应该是左板更远。

实验中约束预测行为维度（5月8日 2.）有一定效果。

观察比赛视频发现，实战中敌人经常在陀螺和非陀螺之间切换，比如它撞墙了，或者我方另外一辆车去撞它，它的陀螺模式都会不稳定。因此，可能需要极快地切换反陀螺和非反陀螺。可以监测角速度的下滑率。

即使接收 shoot_latency 也无法很好解决处理延迟问题，因为处理延迟包含相机图像传输、神经网络 detect、预测器预测、发送给电控的的延迟、电控到机械的延迟。可行的方案：统一采用 STM32 时间，采集图像时记录时刻和序号，一张图对应一个序号，对应一个预测，对应一个Shoot，对应一个发射指令，对应一个子弹飞出侦测。子弹飞出侦测记录的时间减去采集图像的时间就是延迟。

## 5月8日 16:21

上机测试后，优化如下：

1. 放松自瞄打击条件，因为上车时发现高速平移就不打了。
2. 对 Kalman 进行了玄学优化，可选计算模型采用加速度，然而 predict 时仍然假定匀速（之前两者都是匀速模型）。因为如果全部假定匀速，那么滤波器对于长期未观测时“最后的数据”和“首个出现数据”两者反映的速度会极度信任。现在不再会信任首个数据的速度。

> 神经网络的细微误差会导致单板拟合角度出现非正态的较大误差，车辆中心左右漂移2～3cm，导致预测的打击时中心漂移可达10cm。因此回退了之前大量修改，假定车辆匀速旋转，仅在双板面积很接近时用双板拟合去采样角度和半径。这样将无法良好应对非匀速旋转的陀螺。

## 5月6日 14:12

1. 模块分布逻辑：坐标转换器中存有视觉系统外的信息，系统内信息不宜更新系统外信息。
2. 每辆车拥有装甲板数据 id 双阈值注册机制，缓解测试中发现的一个问题：识别到新的装甲板后，该装甲板接下来几帧可能因为抖动而消失，导致陀螺模型直接傻眼。
3. 求解半径数据更严格，测半径更准。
> （已被抛弃）4. 求解角度只采用最优的一个装甲板约束。原因是两个装甲板中较小的识别结果不太准，双约束和单约束切换时角度不连续。
5. 超参数调节。

## 5月3日 20:45

下午上机测试后，修复如下：

1. 活跃旋转检测优化，减少反复两装甲板反复横跳就开启反陀螺的情况。
2. “A 类板”滤波器策略不可靠。如果 A、B 板区分不明显，该滤波器的角度经常会突跃 90 度。现在改用 super 板滤波器，且仍然能与相机 z 轴脱钩。
3. 之前舵轮的半径一直测不准，导致舵轮陀螺抖动巨大。观察发现是因为装甲板较斜时，pnp 测距偏差巨大，可达到 20～30cm。而当前测半径方法非常依赖测量距离的准确性。位置的估计又非常依赖测量所得的半径。因此在两个装甲板像素面积相差较大时，拒绝用当前测量的半径去更新 1 * 1 滤波器中的半径。现在低帧率下打舵轮陀螺，抖动不大。

## Idea

- 需要确认一下神经网络识别结果的尺寸。

- 是否允许预测器同时对 >= 2 辆车进行预测？Pros: 视野中有多辆敌人相互干扰时，自瞄切换目标能迅速进入状态。Cons: 计算效率问题。当前含有迭代法的单次预测在车上耗时已达 5～6ms。其中三分法迭代约 1.6ms。

- 考虑反陀螺模式下枪口本身的甩动对子弹飞行的影响。另外每一装甲板都允许跟随可能不适合打击高速陀螺。

- 神经网络能识别整车后，至少装甲板角度会测很准。

- 非正态分布的数据 -> 如何滤波？

- 电控回传发弹时间戳，让预测器自动调整 PROCESS_LATENCY。思路：连续射击指令中的第一发与连续侦测命中的第一发匹配时间。

- 设置 send 阈值，或设置一定时间内的总偏角的阈值，缓解超调。

- 130+ 的帧率可能导致几个滤波器过于信任短时间内的密集测量值，结果误以为角速度陡增或陡降。反而在低达 20 帧率时部分滤波器发挥稳定。因为角度和长短轴半径（AB板）滤波器接受的数据并不是正态分布。

- 车上旧神经网络识别颜色不太准，无色的容易识别成蓝色。我本地旧神经网络容易把两个装甲板的间隙(sp)识别成装甲板，导致反陀螺突然失效。新神经网络识别出的 sp 我还没想出如何使用。

- 单目在装甲板侧角较大时，1.7m 处的距离偏差就可达 20~30cm。可能导致 CA kalman 测平移运动和反陀螺测半径和中心不准。双目视觉应该可以解决这个问题。

## 5月3日 00:28

装甲板角度滤波与相机 z 轴脱钩。现在滤的是装甲板在大地极坐标系下的极角，数据传入和传出时都需要转换。

> 回退了一次自瞄只选择一个目标的策略，以应对敌方多辆车干扰视野的情况。

## 5月1日 TODO

我们让枪口旋转时，相机的 z 轴也在转，这就导致对陀螺角度的预测存在理论上的问题。当测量值方差 Q 设为较小时，这一个问题可能导致预测的陀螺角速度瞬间下降，导致反陀螺立即停止。

考虑陀螺模块内部计算角度时，与相机的 z 轴进行一个夹角计算。

但是这个几乎无法实现。车辆旋转时，z 轴的角度会突变 -pi -> pi。而目前所有 rotate 都基于相机 z 轴不动的假设。我也很难预测此时应该摆到哪个角度。

如果实测发现角速度因此偏差太大，则加大角度测量值的 Q。

AB 板和角速度滤波器的实现似乎可以大幅简化。

考虑到车辆的自旋是 2，而滤波器内的 (0, 0) 可以重置，可以抛弃 rotate。但是单板的时候依然需要保留“镜头对着的板是长板还是短板”。滤波器存的就是长板在陀螺仪坐标系对于 y 轴的角度，且可以 reduce 到 0 ~ pi 内。该优化预定在5月3日晚上完成。

实测时，需要注意观察舵轮的限制角度在什么范围内可以保证一定命中率和射频。对于不同的角速度，可以设置不同的限制角。

## 5月1日 13:14

1. 三分法模板封装，改用 phi 优选法，提升效率。目前一次预测在 1500 微秒以内。可见这个迭代非常耗时。
2. entry.cpp 监视预测器输出数据是否有 nan 或 inf，如有则重建预测器。

## 5月1日 00:33

> （已被抛弃）1. 暂时信任单板估计的角度，滤波器传入数据方差可调节。
2. 陀螺打击限制宽度范围可调节。
3. 添加发射、命中时间数据记录，方便测量 PROCESS_LATENCY
4. 监视计算效率。目前一次预测在 3ms 以内。
5. 一些常数修改。

## 4月30日文件夹结构

```
predictor
├── base 公用内容
│   ├── defs.hpp: 自定义数据类，如球面坐标
│   ├── tools.hpp: 简化计算函数，如求四边形面积
│   ├── constants.hpp: 常数 
│   ├── parameter.hpp: 动态读取参数线程
│   └── armor_data.hpp: 装甲板信息类以及相关函数
├── kalman 滤波器
│   ├── kalman.hpp: 卡尔曼滤波器模板，允许常量预测、CV、CA
│   └── filter.hpp: 三维坐标滤波器模板
├── robot
│   ├── balance.hpp: 平衡步兵判断类
│   ├── enemy_state.hpp: 敌人信息类，包含 balance.hpp
│   └── coor_transformer.hpp: 坐标转换和系统信息类，包含 enemy_state.hpp。然后为下方文件共用
├── motion
│   ├── armor_model.hpp: 车辆平移运动预测模块，包含 kalman 文件夹中的滤波器
│   ├── top_model.hpp: 车辆陀螺运动过预测模块，包含 kalman 文件夹中的滤波器
│   └── enemy_model.hpp: 车辆运动预测类，包含前两个模块
├── enemy
│   ├── armor_identifier.hpp: 装甲板标号类
│   └── enemy_predictor.hpp: 预测器控制类，包含 enemy_model.hpp
├── entry.cpp: pybind 链接的主程序线程，包含 enemy_predictor.hpp
└── CMakeList.txt

```

- 反陀螺思路：
- 目标：获取车辆中心的平移速度、矩形长短轴长度、长短轴上的装甲板相对车中心的高度、旋转角速度，计算此刻应该往什么方向发射子弹才能让子弹接触敌人时打中装甲板。
- 获取旋转方向：
    - armor_identifier.hpp 为装甲板标上了标号。相邻两帧中，看上去像是同一个的装甲板会有同一标号。
    - 传入装甲板数据时，sorted() 函数保证装甲板从左到右存入。
    - 当视野中装甲板数量从 1 变 2 或者从 2 变 1 时，比较两帧的标号就可以判断旋转方向。比如，标号从 (65, 67) 变成 65，那么对方向右旋转把 67 转过去了。
- 获取敌人装甲板相对自身中心的角度：
    - 当视野中有两块它的装甲板时：
        - 将敌人投影到地面上，四个装甲板在以敌人中心为几何中心的矩形上，所以车辆中心在以两块可见装甲板的连线为直径的圆上。假定中心在圆上某个位置，利用装甲板的尺寸、仰角（比赛规则固定 15 度）的可以算出两块装甲板在像素坐标系的投影。该假设投影与真实投影的相差越小，假设的圆心就越接近真实圆心。这个相差值对于角度应该是一个单峰函数，所以可以用三分法估计角度。
        - 有了角度同时可以得到车辆中心、长短轴长度、高度信息。这些都放进滤波器中。角度放进滤波器中可以得到角速度。
    - 当视野中有一块它的装甲板时：
        - 也可以三分法算出角度。但是仅有一块装甲板时，角度估计的方差很大，此时仅能有一个大致估计，用于判断车辆转速是否足够快。然后根据估计的角度和长短轴信息得到车辆中心。
- 打击决策：
    - 有了以上信息，对此刻发射子弹命中车辆时四块装甲板的位置和角度进行估计。称装甲板正对我们时，他的 "zn_to_l" 角为 0 度，向左转（俯视顺时针）为负方向，向右为正方向。我们限定一个允许打击的 zn_to_l 最大角，在这个范围内进行跟踪式打击，如果没有板子的角度在这个范围内，就让枪口旋转到与旋转方向相反的最大角等待它转过来。

## 4月30日 06:54

已上机测试。根据测试结果，优化如下：

1. 修复 Send 信息中角度太小的问题。
2. 优化线程管理方式。
3. 打击不同车辆的决策优化，可调节最大限制偏差距离。
> （已被抛弃）4. 操作策略修改。未开启自瞄时，每一帧都会选取距离视野中心的车辆为目标，进行预测，不发送信号。开启自瞄时，如果还没有目标，会选择视野中心最近的车辆为目标，如果已有目标，对目标进行预测和打击，即使对方从视野中消失也不会改变目标，直到操作手松开右键取消自瞄才会重新选择目标。

## 4月29日

1. 更新三分法求取角度，删除面积法，提升角度角速度测量准确度。但是在斜坡上测不准。
2. 添加动态调参数功能。
3. 文件夹结构优化，预测器所在文件夹提前一层。

> 车辆中心放弃 CA，很小的加速度在 0.2s 后会带来巨大的误差。

## 4月25日 20:31

1. 反陀螺板块 AB 模式识别逻辑优化。添加了单独 A 和 B 模式，修复了 get_send 中的严重错误。

2. Light 判断两帧之间同一装甲板的逻辑简化，删除 check()。

> （已被抛弃）3. 装甲板的“矫正的图像面积”计算前调用 cv::undistortPoints 缓解相机畸变带来的误差。

4. TopModel2 部分功能模块化。

5. TopModel2 添加了三分法逼近两个装甲板的面积比获取角度的方法，与之前直接用面积比计算角度的方法共同作为角度滤波器的样本。

三分法的假设是车辆中心在以两个装甲板中心的连线为直径的圆上。此时随机取圆上一点作为假想车辆中心，假定两个装甲板垂直于地面，则可以算出两个假想装甲板的空间坐标，进而算出它们的像素面积，它们的面积比越接近真实装甲板的面积比则认为假想点越准确。面积比的接近率是一个关于角度的单峰函数。经过若干次三分法迭代可以得到一个角度估计值。该估计法存在一个系统误差，但不太大。在 l_to_zn 小于 50 度时误差较明显，在实际角度约为 25.3 度时三分法得到了 31 度，面积法得到了 21.3 度。

| 实际 l_to_zn（匀速时手算） | 面积法测量值 | 三分法测量值 |
| -------------------------- | ------------ | ------------ |
| 25.3                       | 21.3         | 31           |
| 29.3                       | 26           | 35           |
| 34.9                       | 32           | 41           |
| 40.5                       | 41.3         | 44           |
| 46.2                       | 46           | 50           |
| 50.5                       | 52.8         | 52           |
| 56.2                       | 61           | 55           |
| 61.8                       | 68           | 61           |
| 67.5                       | 73.7         | 65           |
| 71.7                       | 78.2         | 70           |

【TODO】

- 加速单装甲板时敌方停止陀螺后陀螺模型关闭的速度。

- 陀螺模型添加限定角度打击的功能，而非无脑选择该敌人 yaw pitch 角最小的装甲板。

- 当前 PROCESS_LATENCY 是一个常数。可考虑 PROCESS_LATENCY 自适应功能。注意 PROCESS_LATENCY 包含相机图像传输延迟、识别和预测计算延迟、发弹延迟。
